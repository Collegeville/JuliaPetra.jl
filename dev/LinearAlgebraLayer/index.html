<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear Algebra Layer · JuliaPetra</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JuliaPetra</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../CommunicationLayer/">Communcation Layer</a></li><li><a class="toctext" href="../ProblemDistributionLayer/">Problem Distribution Layer</a></li><li class="current"><a class="toctext" href>Linear Algebra Layer</a><ul class="internal"><li><a class="toctext" href="#MultiVectors-1">MultiVectors</a></li><li><a class="toctext" href="#Operators-1">Operators</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Linear Algebra Layer</a></li></ul><a class="edit-page" href="https://github.com/Collegeville/JuliaPetra.jl/blob/master/docs/src/LinearAlgebraLayer.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Linear Algebra Layer</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Linear-Algebra-Layer-1" href="#Linear-Algebra-Layer-1">Linear Algebra Layer</a></h1><p>The Linear Algebra layer provides the main abstractions for linear algebra codes. The two top level interfaces are <a href="#JuliaPetra.MultiVector"><code>MultiVector</code></a>, for groups of vectors, and <a href="#JuliaPetra.Operator"><code>Operator</code></a>, for operations on <code>MultiVector</code>s.</p><h2><a class="nav-anchor" id="MultiVectors-1" href="#MultiVectors-1">MultiVectors</a></h2><p>MutliVectors support many basic array functions, including broadcasting. Additionally, [<code>dot</code>] and [<code>norm</code>] are supported, however they return arrays since [<code>MultiVector</code>]s may have multiple dot products and norms.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaPetra.MultiVector" href="#JuliaPetra.MultiVector"><code>JuliaPetra.MultiVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>MultiVector</code>s represent a group of vectors to be processed together. They are a subtype of [<code>AbstractArray{Data, 2}</code>] and support the [<code>DistObject</code>], and [<code>SrcDistObject</code>] for transfering between any two <code>MultiVectors</code>. Required methods:</p><pre><code class="language-none">getMap(::MultiVector)
numVectors(::MultiVector)
getLocalArray(::MultiVector{Data})::AbstractMatrix{Data}
similar(::MultiVector{Data})</code></pre><p><code>commReduce(::MultiVector)</code> may need to be overridden if <code>getLocallArray(multiVector)</code> doesn&#39;t return a type useable by <code>sumAll</code>.</p><p>See [<code>DenseMultiVector</code>] for a concrete implementation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Collegeville/JuliaPetra.jl/blob/10209890ec1078c123d89498d6a29eec7b171178/src/MultiVector.jl#L15-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaPetra.DenseMultiVector" href="#JuliaPetra.DenseMultiVector"><code>JuliaPetra.DenseMultiVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>DenseMultiVector represents a dense multi-vector.  Note that all the vectors in a single DenseMultiVector are the same size</p></div></div><a class="source-link" target="_blank" href="https://github.com/Collegeville/JuliaPetra.jl/blob/10209890ec1078c123d89498d6a29eec7b171178/src/DenseMultiVector.jl#L3-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaPetra.localLength" href="#JuliaPetra.localLength"><code>JuliaPetra.localLength</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">localLength(::MultiVector{Data, GID, PID, LID})::LID</code></pre><p>Returns the local length of the vectors in the MultiVector</p></div></div><a class="source-link" target="_blank" href="https://github.com/Collegeville/JuliaPetra.jl/blob/10209890ec1078c123d89498d6a29eec7b171178/src/MultiVector.jl#L40-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaPetra.globalLength" href="#JuliaPetra.globalLength"><code>JuliaPetra.globalLength</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">globalLength(::MultiVector{Data, GID, PID, LID})::GID</code></pre><p>Returns the global length of the vectors in the mutlivector</p></div></div><a class="source-link" target="_blank" href="https://github.com/Collegeville/JuliaPetra.jl/blob/10209890ec1078c123d89498d6a29eec7b171178/src/MultiVector.jl#L33-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaPetra.numVectors" href="#JuliaPetra.numVectors"><code>JuliaPetra.numVectors</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">numVectors(::MultiVector{Data, GID, PID, LID})::LID</code></pre><p>Returns the number of vectors in this <code>MultiVector</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/Collegeville/JuliaPetra.jl/blob/10209890ec1078c123d89498d6a29eec7b171178/src/MultiVector.jl#L341-L345">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaPetra.getVectorView" href="#JuliaPetra.getVectorView"><code>JuliaPetra.getVectorView</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getVectorView(::DenseMultiVector{Data}, columns)::AbstractArray{Data}</code></pre><p>Gets a view of the requested column vector(s) in this DenseMultiVector</p></div></div><a class="source-link" target="_blank" href="https://github.com/Collegeville/JuliaPetra.jl/blob/10209890ec1078c123d89498d6a29eec7b171178/src/MultiVector.jl#L138-L142">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaPetra.getVectorCopy" href="#JuliaPetra.getVectorCopy"><code>JuliaPetra.getVectorCopy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getVectorCopy(::MultiVector{Data}, columns)::Array{Data}</code></pre><p>Gets a copy of the requested column vector(s) in this MultiVector</p></div></div><a class="source-link" target="_blank" href="https://github.com/Collegeville/JuliaPetra.jl/blob/10209890ec1078c123d89498d6a29eec7b171178/src/MultiVector.jl#L145-L149">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaPetra.getLocalArray" href="#JuliaPetra.getLocalArray"><code>JuliaPetra.getLocalArray</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getLocalArray(::MultiVector{Data})::AbstractMatrix{Data}</code></pre><p>Returns the array holding the <code>MultiVector</code>&#39;s local elements. Changes to the array content are be reflected in the <code>MultiVector</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/Collegeville/JuliaPetra.jl/blob/10209890ec1078c123d89498d6a29eec7b171178/src/MultiVector.jl#L348-L353">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaPetra.commReduce" href="#JuliaPetra.commReduce"><code>JuliaPetra.commReduce</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">commReduce(::MultiVector)</code></pre><p>Elementwise reduces the content of the MultiVector across all processes. Note that the MultiVector cannot be distributed globally.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Collegeville/JuliaPetra.jl/blob/10209890ec1078c123d89498d6a29eec7b171178/src/MultiVector.jl#L123-L128">source</a></section><h2><a class="nav-anchor" id="Operators-1" href="#Operators-1">Operators</a></h2><p><code>Operator</code>s represent an operation on a <a href="#JuliaPetra.MultiVector"><code>MultiVector</code></a>, such as a matrix which applies a matrix-vector product.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaPetra.Operator" href="#JuliaPetra.Operator"><code>JuliaPetra.Operator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Operator is a description of all types that have a specific set of methods.</p><p>All Operator types must implement the following methods (with Op standing in for the Operator):</p><pre><code class="language-none">apply!(Y::MultiVector{Data, GID, PID, LID}, operator::Op{Data, GID, PID, LID}, X::MultiVector{Data, GID, PID, LID}, mode::TransposeMode, alpha::Data, beta::Data)</code></pre><p>Computes <span>$Y = α\cdot A^{mode}\cdot X + β\cdot Y$</span>, with the following exceptions</p><ul><li>If beta == 0, apply MUST overwrite Y, so that any values in Y (including NaNs) are ignored.</li><li>If alpha == 0, apply MAY short-circuit the operator, so that any values in X (including NaNs) are ignored</li></ul><pre><code class="language-none">getDomainMap(operator::Op{Data, GID, PID, LID})::BlockMap{GID, PID, LID}</code></pre><p>Returns the BlockMap associated with the domain of this operation</p><pre><code class="language-none">getRangeMap(operator::Op{Data, GID, PID, LID})::BlockMap{GID, PID, LID}</code></pre><p>Returns the BlockMap associated with the range of this operation</p></div></div><a class="source-link" target="_blank" href="https://github.com/Collegeville/JuliaPetra.jl/blob/10209890ec1078c123d89498d6a29eec7b171178/src/Operator.jl#L35-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaPetra.getRangeMap" href="#JuliaPetra.getRangeMap"><code>JuliaPetra.getRangeMap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getRangeMap(::RowGraph{GID, PID, LID})::BlockMap{GID, PID, LID}</code></pre><p>Gets the range map for the graph</p></div></div><a class="source-link" target="_blank" href="https://github.com/Collegeville/JuliaPetra.jl/blob/10209890ec1078c123d89498d6a29eec7b171178/src/RowGraph.jl#L271-L275">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaPetra.getDomainMap" href="#JuliaPetra.getDomainMap"><code>JuliaPetra.getDomainMap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getDomainMap(::RowGraph{GID, PID, LID})::BlockMap{GID, PID, LID}</code></pre><p>Gets the domain map for the graph</p></div></div><a class="source-link" target="_blank" href="https://github.com/Collegeville/JuliaPetra.jl/blob/10209890ec1078c123d89498d6a29eec7b171178/src/RowGraph.jl#L264-L268">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaPetra.apply!" href="#JuliaPetra.apply!"><code>JuliaPetra.apply!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">apply!(Y::MultiVector, operator, X::MultiVector, mode::TransposeMode=NO_TRANS, alpha=1, beta=0)
apply!(Y::MultiVector, operator, X::MultiVector, alpha=1, beta=0)</code></pre><p>Computes <span>$Y = α\cdot A^{mode}\cdot X + β\cdot Y$</span>, with the following exceptions:</p><ul><li>If beta == 0, apply MUST overwrite Y, so that any values in Y (including NaNs) are ignored.</li><li>If alpha == 0, apply MAY short-circuit the operator, so that any values in X (including NaNs) are ignored</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/Collegeville/JuliaPetra.jl/blob/10209890ec1078c123d89498d6a29eec7b171178/src/Operator.jl#L55-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaPetra.apply" href="#JuliaPetra.apply"><code>JuliaPetra.apply</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">apply(Y::MultiVector,operator, X::MultiVector,  mode::TransposeMode=NO_TRANS, alpha=1, beta=0)
apply(Y::MultiVector, operator, X::MultiVector, alpha=1, beta=0)</code></pre><p>As <a href="#JuliaPetra.apply!"><code>apply!</code></a> except returns a new array for the results</p></div></div><a class="source-link" target="_blank" href="https://github.com/Collegeville/JuliaPetra.jl/blob/10209890ec1078c123d89498d6a29eec7b171178/src/Operator.jl#L74-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaPetra.TransposeMode" href="#JuliaPetra.TransposeMode"><code>JuliaPetra.TransposeMode</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Tells JuliaPetra to use the transpose or conjugate transpose of the matrix</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L2">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaPetra.isTransposed" href="#JuliaPetra.isTransposed"><code>JuliaPetra.isTransposed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isTransposed(mode::TransposeMode)::Bool</code></pre><p>Checks whether the given TransposeMode is transposed</p></div></div><a class="source-link" target="_blank" href="https://github.com/Collegeville/JuliaPetra.jl/blob/10209890ec1078c123d89498d6a29eec7b171178/src/Operator.jl#L12-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaPetra.applyConjugation" href="#JuliaPetra.applyConjugation"><code>JuliaPetra.applyConjugation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">applyConjugation(mode::TraseposeMode, val)</code></pre><p>If mode is <code>CONJ_TRANS</code>, the take the conjugate. Otherwise, just return the value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Collegeville/JuliaPetra.jl/blob/10209890ec1078c123d89498d6a29eec7b171178/src/Operator.jl#L19-L24">source</a></section><h3><a class="nav-anchor" id="Matrices-1" href="#Matrices-1">Matrices</a></h3><p>Sparse matrices are the primary <a href="#JuliaPetra.Operator"><code>Operator</code></a> in JuliaPetra.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaPetra.RowMatrix" href="#JuliaPetra.RowMatrix"><code>JuliaPetra.RowMatrix</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>RowMatrix is the base type for all row oriented Petra matrices. RowMatrix fufils both the Operator and DistObject interfaces.</p><pre><code class="language-none">getGraph(mat::RowMatrix)::RowGraph</code></pre><p>Returns the graph that represents the structure of the row matrix</p><pre><code class="language-none">getLocalRowCopy!(copy::Tuple{&lt;:AbstractVector{&lt;:Integer}, &lt;:AbstractVector{Data}}, matrix::RowMatrix{Data, GID, PID, LID}, localRow::LID)::Integer</code></pre><p>Copies the given row into the provided arrays and returns the number of elements in that row using local indices</p><pre><code class="language-none">getGlobalRowCopy!(copy::Tuple{&lt;:AbstractVector{&lt;:Integer}, &lt;:AbstractVector{Data}}, matrix::RowMatrix{Data, GID, PID, LID}, globalRow::GID)::Integer</code></pre><p>Copies the given row into the provided arrays and returns the number of elements in that row using global indices</p><pre><code class="language-none">getGlobalRowView(matrix::RowMatrix{Data, GID, PID, LID}, globalRow::Integer)::Tuple{AbstractArray{GID, 1}, AbstractArray{Data, 1}}</code></pre><p>Returns a view to the given row using global indices</p><pre><code class="language-none">getLocalRowView(matrix::RowMatrix{Data, GID, PID, LID},localRow::Integer)::Tuple{AbstractArray{GID, 1}, AbstractArray{Data, 1}}</code></pre><p>Returns a view to the given row using local indices</p><pre><code class="language-none">getLocalDiagCopy!(copy::MultiVector{Data, GID, PID, LID}, matrix::RowMatrix{Data, GID, PID, LID})::MultiVector{Data, GID, PID, LID}</code></pre><p>Copies the local diagonal into the given <code>MultiVector</code> then returns the <code>MultiVector</code></p><pre><code class="language-none">leftScale!(matrix::RowMatrix{Data, GID, PID, LID}, X::AbstractArray{Data, 1})</code></pre><p>Scales matrix on the left with X</p><pre><code class="language-none">rightScale!(matrix::RowMatrix{Data, GID, PID, LID}, X::AbstractArray{Data, 1})</code></pre><p>Scales matrix on the right with X</p><p><code>getMap(...)</code>, as required by SrcDistObject, is implemented by calling <code>getRowMap(...)</code></p><p><code>apply!(...)</code>, as required by Operator, is implemented, but can be optimized by overrideing the following method     localApply(Y::MultiVector, A::RowMatrix, X::MultiVector, ::TransposeMode, α::Data, β::Data) Does the computations for <code>Y = β⋅Y + α⋅A⋅X</code>, <code>X</code> and <code>Y</code> match the row map and column map, depending on the transpose mode</p><p>The following methods are currently implemented as no-ops, but can be overridden to improve performance.</p><pre><code class="language-none">setColumnMapMultiVector(::RowMatrix{Data, GID, PID, LID}, ::Union{MultiVector{Data, GID, PID, LID}, Nothing})</code></pre><p>Caches a <code>MultiVector</code> that uses the matrix&#39;s column map.</p><pre><code class="language-none">getColumnMapMultiVector(::RowMatrix{Data, GID, PID, LID})::Union{MultiVector{Data, GID, PID, LID}, Nothing}</code></pre><p>Fetches any cached <code>MultiVector</code> that uses the matrix&#39;s column map.</p><pre><code class="language-none">setRowMapMultiVector(::RowMatrix{Data, GID, PID, LID}, ::Union{MultiVector{Data, GID, PID, LID}, Nothing})</code></pre><p>Caches a <code>MultiVector</code> that uses the matrix&#39;s row map.</p><pre><code class="language-none">getRowMapMultiVector(::RowMatrix{Data, GID, PID, LID})::Union{MultiVector{Data, GID, PID, LID}, Nothing}</code></pre><p>Fetches any cached <code>MultiVector</code> that uses the matrix&#39;s row map.</p><p>Some pre-implemented methods can be optimized by providing specialized implementations <code>apply!</code>, as mentioned above All <code>RowMatrix</code> methods that are also implemented by <code>RowGraph</code> are implemented using <code>getGraph</code>. <code>pack</code> is implemented using <code>getLocalRowCopy</code> <code>getGlobalRowCopy!</code> is implemented by calling <code>getLocalRowCopy!</code> and remapping the values using <code>gid(::BlockMap, ::Integer)</code></p><p>Additionally, Julia&#39;s <code>mul!</code> and <code>*</code> functions are implemented for <code>RowMatrix</code>-<code>MultiVector</code> products</p></div></div><a class="source-link" target="_blank" href="https://github.com/Collegeville/JuliaPetra.jl/blob/10209890ec1078c123d89498d6a29eec7b171178/src/RowMatrix.jl#L7-L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaPetra.CSRMatrix" href="#JuliaPetra.CSRMatrix"><code>JuliaPetra.CSRMatrix</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An implementation of <a href="#JuliaPetra.RowMatrix"><code>RowMatrix</code></a> that uses CSR format</p></div></div><a class="source-link" target="_blank" href="https://github.com/Collegeville/JuliaPetra.jl/blob/10209890ec1078c123d89498d6a29eec7b171178/src/CSRMatrix.jl#L3-L5">source</a></section><footer><hr/><a class="previous" href="../ProblemDistributionLayer/"><span class="direction">Previous</span><span class="title">Problem Distribution Layer</span></a></footer></article></body></html>
